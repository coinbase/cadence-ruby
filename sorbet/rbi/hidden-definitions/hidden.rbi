# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Cadence::Client
  include ::Cadence::Testing::CadenceOverride
end

class Cadence::Configuration::Connection
  def self.[](*_); end

  def self.members(); end
end

class Cadence::Configuration::Execution
  def self.[](*_); end

  def self.members(); end
end

class Cadence::Workflow
  extend ::Cadence::Testing::WorkflowOverride
end

module Cadence
  def self.complete_activity(*args, &block); end

  def self.fail_activity(*args, &block); end

  def self.fetch_workflow_execution_info(*args, &block); end

  def self.get_workflow_history(*args, &block); end

  def self.register_domain(*args, &block); end

  def self.reset_workflow(*args, &block); end

  def self.schedule_workflow(*args, &block); end

  def self.signal_workflow(*args, &block); end

  def self.start_workflow(*args, &block); end

  def self.terminate_workflow(*args, &block); end
end

class CadenceThrift::AccessDeniedError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::ActivityTaskCancelRequestedEventAttributes
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end
end

class CadenceThrift::ActivityTaskCanceledEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def latestCancelRequestedEventId(); end

  def latestCancelRequestedEventId=(value); end

  def latestCancelRequestedEventId?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end
end

class CadenceThrift::ActivityTaskCompletedEventAttributes
  def identity(); end

  def identity=(value); end

  def identity?(); end

  def result(); end

  def result=(value); end

  def result?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end
end

class CadenceThrift::ActivityTaskFailedEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end
end

class CadenceThrift::ActivityTaskScheduledEventAttributes
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end

  def activityType(); end

  def activityType=(value); end

  def activityType?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def heartbeatTimeoutSeconds(); end

  def heartbeatTimeoutSeconds=(value); end

  def heartbeatTimeoutSeconds?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def scheduleToCloseTimeoutSeconds(); end

  def scheduleToCloseTimeoutSeconds=(value); end

  def scheduleToCloseTimeoutSeconds?(); end

  def scheduleToStartTimeoutSeconds(); end

  def scheduleToStartTimeoutSeconds=(value); end

  def scheduleToStartTimeoutSeconds?(); end

  def startToCloseTimeoutSeconds(); end

  def startToCloseTimeoutSeconds=(value); end

  def startToCloseTimeoutSeconds?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end
end

class CadenceThrift::ActivityTaskStartedEventAttributes
  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end
end

class CadenceThrift::ActivityTaskTimedOutEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def timeoutType(); end

  def timeoutType=(value); end

  def timeoutType?(); end
end

class CadenceThrift::ActivityType
  def name(); end

  def name=(value); end

  def name?(); end
end

class CadenceThrift::BadBinaries
  def binaries(); end

  def binaries=(value); end

  def binaries?(); end
end

class CadenceThrift::BadBinaryInfo
  def createdTimeNano(); end

  def createdTimeNano=(value); end

  def createdTimeNano?(); end

  def operator(); end

  def operator=(value); end

  def operator?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end
end

class CadenceThrift::BadRequestError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::CancelTimerDecisionAttributes
  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::CancelTimerFailedEventAttributes
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::CancelWorkflowExecutionDecisionAttributes
  def details(); end

  def details=(value); end

  def details?(); end
end

class CadenceThrift::CancellationAlreadyRequestedError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::ChildWorkflowExecutionCanceledEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ChildWorkflowExecutionCompletedEventAttributes
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def result(); end

  def result=(value); end

  def result?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ChildWorkflowExecutionFailedEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ChildWorkflowExecutionStartedEventAttributes
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ChildWorkflowExecutionTerminatedEventAttributes
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ChildWorkflowExecutionTimedOutEventAttributes
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def timeoutType(); end

  def timeoutType=(value); end

  def timeoutType?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::ClientVersionNotSupportedError
  def clientImpl(); end

  def clientImpl=(value); end

  def clientImpl?(); end

  def featureVersion(); end

  def featureVersion=(value); end

  def featureVersion?(); end

  def initialize(*args, &block); end

  def struct_initialize(d=T.unsafe(nil), &block); end

  def supportedVersions(); end

  def supportedVersions=(value); end

  def supportedVersions?(); end
end

class CadenceThrift::CloseShardRequest
  def shardID(); end

  def shardID=(value); end

  def shardID?(); end
end

class CadenceThrift::ClusterReplicationConfiguration
  def clusterName(); end

  def clusterName=(value); end

  def clusterName?(); end
end

class CadenceThrift::CompleteWorkflowExecutionDecisionAttributes
  def result(); end

  def result=(value); end

  def result?(); end
end

class CadenceThrift::ContinueAsNewWorkflowExecutionDecisionAttributes
  def backoffStartIntervalInSeconds(); end

  def backoffStartIntervalInSeconds=(value); end

  def backoffStartIntervalInSeconds?(); end

  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def failureDetails(); end

  def failureDetails=(value); end

  def failureDetails?(); end

  def failureReason(); end

  def failureReason=(value); end

  def failureReason?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def initiator(); end

  def initiator=(value); end

  def initiator?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def lastCompletionResult(); end

  def lastCompletionResult=(value); end

  def lastCompletionResult?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::CountWorkflowExecutionsRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def query(); end

  def query=(value); end

  def query?(); end
end

class CadenceThrift::CountWorkflowExecutionsResponse
  def count(); end

  def count=(value); end

  def count?(); end
end

class CadenceThrift::DataBlob
  def Data(); end

  def Data=(value); end

  def Data?(); end

  def EncodingType(); end

  def EncodingType=(value); end

  def EncodingType?(); end
end

class CadenceThrift::Decision
  def cancelTimerDecisionAttributes(); end

  def cancelTimerDecisionAttributes=(value); end

  def cancelTimerDecisionAttributes?(); end

  def cancelWorkflowExecutionDecisionAttributes(); end

  def cancelWorkflowExecutionDecisionAttributes=(value); end

  def cancelWorkflowExecutionDecisionAttributes?(); end

  def completeWorkflowExecutionDecisionAttributes(); end

  def completeWorkflowExecutionDecisionAttributes=(value); end

  def completeWorkflowExecutionDecisionAttributes?(); end

  def continueAsNewWorkflowExecutionDecisionAttributes(); end

  def continueAsNewWorkflowExecutionDecisionAttributes=(value); end

  def continueAsNewWorkflowExecutionDecisionAttributes?(); end

  def decisionType(); end

  def decisionType=(value); end

  def decisionType?(); end

  def failWorkflowExecutionDecisionAttributes(); end

  def failWorkflowExecutionDecisionAttributes=(value); end

  def failWorkflowExecutionDecisionAttributes?(); end

  def recordMarkerDecisionAttributes(); end

  def recordMarkerDecisionAttributes=(value); end

  def recordMarkerDecisionAttributes?(); end

  def requestCancelActivityTaskDecisionAttributes(); end

  def requestCancelActivityTaskDecisionAttributes=(value); end

  def requestCancelActivityTaskDecisionAttributes?(); end

  def requestCancelExternalWorkflowExecutionDecisionAttributes(); end

  def requestCancelExternalWorkflowExecutionDecisionAttributes=(value); end

  def requestCancelExternalWorkflowExecutionDecisionAttributes?(); end

  def scheduleActivityTaskDecisionAttributes(); end

  def scheduleActivityTaskDecisionAttributes=(value); end

  def scheduleActivityTaskDecisionAttributes?(); end

  def signalExternalWorkflowExecutionDecisionAttributes(); end

  def signalExternalWorkflowExecutionDecisionAttributes=(value); end

  def signalExternalWorkflowExecutionDecisionAttributes?(); end

  def startChildWorkflowExecutionDecisionAttributes(); end

  def startChildWorkflowExecutionDecisionAttributes=(value); end

  def startChildWorkflowExecutionDecisionAttributes?(); end

  def startTimerDecisionAttributes(); end

  def startTimerDecisionAttributes=(value); end

  def startTimerDecisionAttributes?(); end

  def upsertWorkflowSearchAttributesDecisionAttributes(); end

  def upsertWorkflowSearchAttributesDecisionAttributes=(value); end

  def upsertWorkflowSearchAttributesDecisionAttributes?(); end
end

class CadenceThrift::DecisionTaskCompletedEventAttributes
  def binaryChecksum(); end

  def binaryChecksum=(value); end

  def binaryChecksum?(); end

  def executionContext(); end

  def executionContext=(value); end

  def executionContext?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end
end

class CadenceThrift::DecisionTaskFailedEventAttributes
  def baseRunId(); end

  def baseRunId=(value); end

  def baseRunId?(); end

  def cause(); end

  def cause=(value); end

  def cause?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def forkEventVersion(); end

  def forkEventVersion=(value); end

  def forkEventVersion?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def newRunId(); end

  def newRunId=(value); end

  def newRunId?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end
end

class CadenceThrift::DecisionTaskScheduledEventAttributes
  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def startToCloseTimeoutSeconds(); end

  def startToCloseTimeoutSeconds=(value); end

  def startToCloseTimeoutSeconds?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end
end

class CadenceThrift::DecisionTaskStartedEventAttributes
  def identity(); end

  def identity=(value); end

  def identity?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end
end

class CadenceThrift::DecisionTaskTimedOutEventAttributes
  def scheduledEventId(); end

  def scheduledEventId=(value); end

  def scheduledEventId?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def timeoutType(); end

  def timeoutType=(value); end

  def timeoutType?(); end
end

class CadenceThrift::DeprecateDomainRequest
  def name(); end

  def name=(value); end

  def name?(); end

  def securityToken(); end

  def securityToken=(value); end

  def securityToken?(); end
end

class CadenceThrift::DescribeDomainRequest
  def name(); end

  def name=(value); end

  def name?(); end

  def uuid(); end

  def uuid=(value); end

  def uuid?(); end
end

class CadenceThrift::DescribeDomainResponse
  def configuration(); end

  def configuration=(value); end

  def configuration?(); end

  def domainInfo(); end

  def domainInfo=(value); end

  def domainInfo?(); end

  def failoverVersion(); end

  def failoverVersion=(value); end

  def failoverVersion?(); end

  def isGlobalDomain(); end

  def isGlobalDomain=(value); end

  def isGlobalDomain?(); end

  def replicationConfiguration(); end

  def replicationConfiguration=(value); end

  def replicationConfiguration?(); end
end

class CadenceThrift::DescribeHistoryHostRequest
  def executionForHost(); end

  def executionForHost=(value); end

  def executionForHost?(); end

  def hostAddress(); end

  def hostAddress=(value); end

  def hostAddress?(); end

  def shardIdForHost(); end

  def shardIdForHost=(value); end

  def shardIdForHost?(); end
end

class CadenceThrift::DescribeHistoryHostResponse
  def address(); end

  def address=(value); end

  def address?(); end

  def domainCache(); end

  def domainCache=(value); end

  def domainCache?(); end

  def numberOfShards(); end

  def numberOfShards=(value); end

  def numberOfShards?(); end

  def shardControllerStatus(); end

  def shardControllerStatus=(value); end

  def shardControllerStatus?(); end

  def shardIDs(); end

  def shardIDs=(value); end

  def shardIDs?(); end
end

class CadenceThrift::DescribeTaskListRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def includeTaskListStatus(); end

  def includeTaskListStatus=(value); end

  def includeTaskListStatus?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskListType(); end

  def taskListType=(value); end

  def taskListType?(); end
end

class CadenceThrift::DescribeTaskListResponse
  def pollers(); end

  def pollers=(value); end

  def pollers?(); end

  def taskListStatus(); end

  def taskListStatus=(value); end

  def taskListStatus?(); end
end

class CadenceThrift::DescribeWorkflowExecutionRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end
end

class CadenceThrift::DescribeWorkflowExecutionResponse
  def executionConfiguration(); end

  def executionConfiguration=(value); end

  def executionConfiguration?(); end

  def pendingActivities(); end

  def pendingActivities=(value); end

  def pendingActivities?(); end

  def pendingChildren(); end

  def pendingChildren=(value); end

  def pendingChildren?(); end

  def workflowExecutionInfo(); end

  def workflowExecutionInfo=(value); end

  def workflowExecutionInfo?(); end
end

class CadenceThrift::DomainAlreadyExistsError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::DomainCacheInfo
  def numOfItemsInCacheByID(); end

  def numOfItemsInCacheByID=(value); end

  def numOfItemsInCacheByID?(); end

  def numOfItemsInCacheByName(); end

  def numOfItemsInCacheByName=(value); end

  def numOfItemsInCacheByName?(); end
end

class CadenceThrift::DomainConfiguration
  def badBinaries(); end

  def badBinaries=(value); end

  def badBinaries?(); end

  def emitMetric(); end

  def emitMetric=(value); end

  def emitMetric?(); end

  def historyArchivalStatus(); end

  def historyArchivalStatus=(value); end

  def historyArchivalStatus?(); end

  def historyArchivalURI(); end

  def historyArchivalURI=(value); end

  def historyArchivalURI?(); end

  def visibilityArchivalStatus(); end

  def visibilityArchivalStatus=(value); end

  def visibilityArchivalStatus?(); end

  def visibilityArchivalURI(); end

  def visibilityArchivalURI=(value); end

  def visibilityArchivalURI?(); end

  def workflowExecutionRetentionPeriodInDays(); end

  def workflowExecutionRetentionPeriodInDays=(value); end

  def workflowExecutionRetentionPeriodInDays?(); end
end

class CadenceThrift::DomainInfo
  def data(); end

  def data=(value); end

  def data?(); end

  def description(); end

  def description=(value); end

  def description?(); end

  def name(); end

  def name=(value); end

  def name?(); end

  def ownerEmail(); end

  def ownerEmail=(value); end

  def ownerEmail?(); end

  def status(); end

  def status=(value); end

  def status?(); end

  def uuid(); end

  def uuid=(value); end

  def uuid?(); end
end

class CadenceThrift::DomainNotActiveError
  def activeCluster(); end

  def activeCluster=(value); end

  def activeCluster?(); end

  def currentCluster(); end

  def currentCluster=(value); end

  def currentCluster?(); end

  def domainName(); end

  def domainName=(value); end

  def domainName?(); end

  def initialize(*args, &block); end

  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::DomainReplicationConfiguration
  def activeClusterName(); end

  def activeClusterName=(value); end

  def activeClusterName?(); end

  def clusters(); end

  def clusters=(value); end

  def clusters?(); end
end

class CadenceThrift::EntityNotExistsError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::ExternalWorkflowExecutionCancelRequestedEventAttributes
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::ExternalWorkflowExecutionSignaledEventAttributes
  def control(); end

  def control=(value); end

  def control?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::FailWorkflowExecutionDecisionAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end
end

class CadenceThrift::GetSearchAttributesResponse
  def keys(); end

  def keys=(value); end

  def keys?(); end
end

class CadenceThrift::GetWorkflowExecutionHistoryRequest
  def HistoryEventFilterType(); end

  def HistoryEventFilterType=(value); end

  def HistoryEventFilterType?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end

  def maximumPageSize(); end

  def maximumPageSize=(value); end

  def maximumPageSize?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def waitForNewEvent(); end

  def waitForNewEvent=(value); end

  def waitForNewEvent?(); end
end

class CadenceThrift::GetWorkflowExecutionHistoryResponse
  def archived(); end

  def archived=(value); end

  def archived?(); end

  def history(); end

  def history=(value); end

  def history?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::Header
  def fields(); end

  def fields=(value); end

  def fields?(); end
end

class CadenceThrift::History
  def events(); end

  def events=(value); end

  def events?(); end
end

class CadenceThrift::HistoryBranch
  def ancestors(); end

  def ancestors=(value); end

  def ancestors?(); end

  def branchID(); end

  def branchID=(value); end

  def branchID?(); end

  def treeID(); end

  def treeID=(value); end

  def treeID?(); end
end

class CadenceThrift::HistoryBranchRange
  def beginNodeID(); end

  def beginNodeID=(value); end

  def beginNodeID?(); end

  def branchID(); end

  def branchID=(value); end

  def branchID?(); end

  def endNodeID(); end

  def endNodeID=(value); end

  def endNodeID?(); end
end

class CadenceThrift::HistoryEvent
  def activityTaskCancelRequestedEventAttributes(); end

  def activityTaskCancelRequestedEventAttributes=(value); end

  def activityTaskCancelRequestedEventAttributes?(); end

  def activityTaskCanceledEventAttributes(); end

  def activityTaskCanceledEventAttributes=(value); end

  def activityTaskCanceledEventAttributes?(); end

  def activityTaskCompletedEventAttributes(); end

  def activityTaskCompletedEventAttributes=(value); end

  def activityTaskCompletedEventAttributes?(); end

  def activityTaskFailedEventAttributes(); end

  def activityTaskFailedEventAttributes=(value); end

  def activityTaskFailedEventAttributes?(); end

  def activityTaskScheduledEventAttributes(); end

  def activityTaskScheduledEventAttributes=(value); end

  def activityTaskScheduledEventAttributes?(); end

  def activityTaskStartedEventAttributes(); end

  def activityTaskStartedEventAttributes=(value); end

  def activityTaskStartedEventAttributes?(); end

  def activityTaskTimedOutEventAttributes(); end

  def activityTaskTimedOutEventAttributes=(value); end

  def activityTaskTimedOutEventAttributes?(); end

  def cancelTimerFailedEventAttributes(); end

  def cancelTimerFailedEventAttributes=(value); end

  def cancelTimerFailedEventAttributes?(); end

  def childWorkflowExecutionCanceledEventAttributes(); end

  def childWorkflowExecutionCanceledEventAttributes=(value); end

  def childWorkflowExecutionCanceledEventAttributes?(); end

  def childWorkflowExecutionCompletedEventAttributes(); end

  def childWorkflowExecutionCompletedEventAttributes=(value); end

  def childWorkflowExecutionCompletedEventAttributes?(); end

  def childWorkflowExecutionFailedEventAttributes(); end

  def childWorkflowExecutionFailedEventAttributes=(value); end

  def childWorkflowExecutionFailedEventAttributes?(); end

  def childWorkflowExecutionStartedEventAttributes(); end

  def childWorkflowExecutionStartedEventAttributes=(value); end

  def childWorkflowExecutionStartedEventAttributes?(); end

  def childWorkflowExecutionTerminatedEventAttributes(); end

  def childWorkflowExecutionTerminatedEventAttributes=(value); end

  def childWorkflowExecutionTerminatedEventAttributes?(); end

  def childWorkflowExecutionTimedOutEventAttributes(); end

  def childWorkflowExecutionTimedOutEventAttributes=(value); end

  def childWorkflowExecutionTimedOutEventAttributes?(); end

  def decisionTaskCompletedEventAttributes(); end

  def decisionTaskCompletedEventAttributes=(value); end

  def decisionTaskCompletedEventAttributes?(); end

  def decisionTaskFailedEventAttributes(); end

  def decisionTaskFailedEventAttributes=(value); end

  def decisionTaskFailedEventAttributes?(); end

  def decisionTaskScheduledEventAttributes(); end

  def decisionTaskScheduledEventAttributes=(value); end

  def decisionTaskScheduledEventAttributes?(); end

  def decisionTaskStartedEventAttributes(); end

  def decisionTaskStartedEventAttributes=(value); end

  def decisionTaskStartedEventAttributes?(); end

  def decisionTaskTimedOutEventAttributes(); end

  def decisionTaskTimedOutEventAttributes=(value); end

  def decisionTaskTimedOutEventAttributes?(); end

  def eventId(); end

  def eventId=(value); end

  def eventId?(); end

  def eventType(); end

  def eventType=(value); end

  def eventType?(); end

  def externalWorkflowExecutionCancelRequestedEventAttributes(); end

  def externalWorkflowExecutionCancelRequestedEventAttributes=(value); end

  def externalWorkflowExecutionCancelRequestedEventAttributes?(); end

  def externalWorkflowExecutionSignaledEventAttributes(); end

  def externalWorkflowExecutionSignaledEventAttributes=(value); end

  def externalWorkflowExecutionSignaledEventAttributes?(); end

  def markerRecordedEventAttributes(); end

  def markerRecordedEventAttributes=(value); end

  def markerRecordedEventAttributes?(); end

  def requestCancelActivityTaskFailedEventAttributes(); end

  def requestCancelActivityTaskFailedEventAttributes=(value); end

  def requestCancelActivityTaskFailedEventAttributes?(); end

  def requestCancelExternalWorkflowExecutionFailedEventAttributes(); end

  def requestCancelExternalWorkflowExecutionFailedEventAttributes=(value); end

  def requestCancelExternalWorkflowExecutionFailedEventAttributes?(); end

  def requestCancelExternalWorkflowExecutionInitiatedEventAttributes(); end

  def requestCancelExternalWorkflowExecutionInitiatedEventAttributes=(value); end

  def requestCancelExternalWorkflowExecutionInitiatedEventAttributes?(); end

  def signalExternalWorkflowExecutionFailedEventAttributes(); end

  def signalExternalWorkflowExecutionFailedEventAttributes=(value); end

  def signalExternalWorkflowExecutionFailedEventAttributes?(); end

  def signalExternalWorkflowExecutionInitiatedEventAttributes(); end

  def signalExternalWorkflowExecutionInitiatedEventAttributes=(value); end

  def signalExternalWorkflowExecutionInitiatedEventAttributes?(); end

  def startChildWorkflowExecutionFailedEventAttributes(); end

  def startChildWorkflowExecutionFailedEventAttributes=(value); end

  def startChildWorkflowExecutionFailedEventAttributes?(); end

  def startChildWorkflowExecutionInitiatedEventAttributes(); end

  def startChildWorkflowExecutionInitiatedEventAttributes=(value); end

  def startChildWorkflowExecutionInitiatedEventAttributes?(); end

  def taskId(); end

  def taskId=(value); end

  def taskId?(); end

  def timerCanceledEventAttributes(); end

  def timerCanceledEventAttributes=(value); end

  def timerCanceledEventAttributes?(); end

  def timerFiredEventAttributes(); end

  def timerFiredEventAttributes=(value); end

  def timerFiredEventAttributes?(); end

  def timerStartedEventAttributes(); end

  def timerStartedEventAttributes=(value); end

  def timerStartedEventAttributes?(); end

  def timestamp(); end

  def timestamp=(value); end

  def timestamp?(); end

  def upsertWorkflowSearchAttributesEventAttributes(); end

  def upsertWorkflowSearchAttributesEventAttributes=(value); end

  def upsertWorkflowSearchAttributesEventAttributes?(); end

  def version(); end

  def version=(value); end

  def version?(); end

  def workflowExecutionCancelRequestedEventAttributes(); end

  def workflowExecutionCancelRequestedEventAttributes=(value); end

  def workflowExecutionCancelRequestedEventAttributes?(); end

  def workflowExecutionCanceledEventAttributes(); end

  def workflowExecutionCanceledEventAttributes=(value); end

  def workflowExecutionCanceledEventAttributes?(); end

  def workflowExecutionCompletedEventAttributes(); end

  def workflowExecutionCompletedEventAttributes=(value); end

  def workflowExecutionCompletedEventAttributes?(); end

  def workflowExecutionContinuedAsNewEventAttributes(); end

  def workflowExecutionContinuedAsNewEventAttributes=(value); end

  def workflowExecutionContinuedAsNewEventAttributes?(); end

  def workflowExecutionFailedEventAttributes(); end

  def workflowExecutionFailedEventAttributes=(value); end

  def workflowExecutionFailedEventAttributes?(); end

  def workflowExecutionSignaledEventAttributes(); end

  def workflowExecutionSignaledEventAttributes=(value); end

  def workflowExecutionSignaledEventAttributes?(); end

  def workflowExecutionStartedEventAttributes(); end

  def workflowExecutionStartedEventAttributes=(value); end

  def workflowExecutionStartedEventAttributes?(); end

  def workflowExecutionTerminatedEventAttributes(); end

  def workflowExecutionTerminatedEventAttributes=(value); end

  def workflowExecutionTerminatedEventAttributes?(); end

  def workflowExecutionTimedOutEventAttributes(); end

  def workflowExecutionTimedOutEventAttributes=(value); end

  def workflowExecutionTimedOutEventAttributes?(); end
end

class CadenceThrift::InternalServiceError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::LimitExceededError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::ListArchivedWorkflowExecutionsRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def pageSize(); end

  def pageSize=(value); end

  def pageSize?(); end

  def query(); end

  def query=(value); end

  def query?(); end
end

class CadenceThrift::ListArchivedWorkflowExecutionsResponse
  def executions(); end

  def executions=(value); end

  def executions?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::ListClosedWorkflowExecutionsRequest
  def StartTimeFilter(); end

  def StartTimeFilter=(value); end

  def StartTimeFilter?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionFilter(); end

  def executionFilter=(value); end

  def executionFilter?(); end

  def maximumPageSize(); end

  def maximumPageSize=(value); end

  def maximumPageSize?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def statusFilter(); end

  def statusFilter=(value); end

  def statusFilter?(); end

  def typeFilter(); end

  def typeFilter=(value); end

  def typeFilter?(); end
end

class CadenceThrift::ListClosedWorkflowExecutionsResponse
  def executions(); end

  def executions=(value); end

  def executions?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::ListDomainsRequest
  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def pageSize(); end

  def pageSize=(value); end

  def pageSize?(); end
end

class CadenceThrift::ListDomainsResponse
  def domains(); end

  def domains=(value); end

  def domains?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::ListOpenWorkflowExecutionsRequest
  def StartTimeFilter(); end

  def StartTimeFilter=(value); end

  def StartTimeFilter?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionFilter(); end

  def executionFilter=(value); end

  def executionFilter?(); end

  def maximumPageSize(); end

  def maximumPageSize=(value); end

  def maximumPageSize?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def typeFilter(); end

  def typeFilter=(value); end

  def typeFilter?(); end
end

class CadenceThrift::ListOpenWorkflowExecutionsResponse
  def executions(); end

  def executions=(value); end

  def executions?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::ListWorkflowExecutionsRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def pageSize(); end

  def pageSize=(value); end

  def pageSize?(); end

  def query(); end

  def query=(value); end

  def query?(); end
end

class CadenceThrift::ListWorkflowExecutionsResponse
  def executions(); end

  def executions=(value); end

  def executions?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end
end

class CadenceThrift::MarkerRecordedEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def markerName(); end

  def markerName=(value); end

  def markerName?(); end
end

class CadenceThrift::Memo
  def fields(); end

  def fields=(value); end

  def fields?(); end
end

class CadenceThrift::PendingActivityInfo
  def activityID(); end

  def activityID=(value); end

  def activityID?(); end

  def activityType(); end

  def activityType=(value); end

  def activityType?(); end

  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def expirationTimestamp(); end

  def expirationTimestamp=(value); end

  def expirationTimestamp?(); end

  def heartbeatDetails(); end

  def heartbeatDetails=(value); end

  def heartbeatDetails?(); end

  def lastFailureDetails(); end

  def lastFailureDetails=(value); end

  def lastFailureDetails?(); end

  def lastFailureReason(); end

  def lastFailureReason=(value); end

  def lastFailureReason?(); end

  def lastHeartbeatTimestamp(); end

  def lastHeartbeatTimestamp=(value); end

  def lastHeartbeatTimestamp?(); end

  def lastStartedTimestamp(); end

  def lastStartedTimestamp=(value); end

  def lastStartedTimestamp?(); end

  def lastWorkerIdentity(); end

  def lastWorkerIdentity=(value); end

  def lastWorkerIdentity?(); end

  def maximumAttempts(); end

  def maximumAttempts=(value); end

  def maximumAttempts?(); end

  def scheduledTimestamp(); end

  def scheduledTimestamp=(value); end

  def scheduledTimestamp?(); end

  def state(); end

  def state=(value); end

  def state?(); end
end

class CadenceThrift::PendingChildExecutionInfo
  def initiatedID(); end

  def initiatedID=(value); end

  def initiatedID?(); end

  def parentClosePolicy(); end

  def parentClosePolicy=(value); end

  def parentClosePolicy?(); end

  def runID(); end

  def runID=(value); end

  def runID?(); end

  def workflowID(); end

  def workflowID=(value); end

  def workflowID?(); end

  def workflowTypName(); end

  def workflowTypName=(value); end

  def workflowTypName?(); end
end

class CadenceThrift::PollForActivityTaskRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskListMetadata(); end

  def taskListMetadata=(value); end

  def taskListMetadata?(); end
end

class CadenceThrift::PollForActivityTaskResponse
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end

  def activityType(); end

  def activityType=(value); end

  def activityType?(); end

  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def heartbeatDetails(); end

  def heartbeatDetails=(value); end

  def heartbeatDetails?(); end

  def heartbeatTimeoutSeconds(); end

  def heartbeatTimeoutSeconds=(value); end

  def heartbeatTimeoutSeconds?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def scheduleToCloseTimeoutSeconds(); end

  def scheduleToCloseTimeoutSeconds=(value); end

  def scheduleToCloseTimeoutSeconds?(); end

  def scheduledTimestamp(); end

  def scheduledTimestamp=(value); end

  def scheduledTimestamp?(); end

  def scheduledTimestampOfThisAttempt(); end

  def scheduledTimestampOfThisAttempt=(value); end

  def scheduledTimestampOfThisAttempt?(); end

  def startToCloseTimeoutSeconds(); end

  def startToCloseTimeoutSeconds=(value); end

  def startToCloseTimeoutSeconds?(); end

  def startedTimestamp(); end

  def startedTimestamp=(value); end

  def startedTimestamp?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end

  def workflowDomain(); end

  def workflowDomain=(value); end

  def workflowDomain?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::PollForDecisionTaskRequest
  def binaryChecksum(); end

  def binaryChecksum=(value); end

  def binaryChecksum?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end
end

class CadenceThrift::PollForDecisionTaskResponse
  def WorkflowExecutionTaskList(); end

  def WorkflowExecutionTaskList=(value); end

  def WorkflowExecutionTaskList?(); end

  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def backlogCountHint(); end

  def backlogCountHint=(value); end

  def backlogCountHint?(); end

  def history(); end

  def history=(value); end

  def history?(); end

  def nextPageToken(); end

  def nextPageToken=(value); end

  def nextPageToken?(); end

  def previousStartedEventId(); end

  def previousStartedEventId=(value); end

  def previousStartedEventId?(); end

  def queries(); end

  def queries=(value); end

  def queries?(); end

  def query(); end

  def query=(value); end

  def query?(); end

  def scheduledTimestamp(); end

  def scheduledTimestamp=(value); end

  def scheduledTimestamp?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def startedTimestamp(); end

  def startedTimestamp=(value); end

  def startedTimestamp?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::PollerInfo
  def identity(); end

  def identity=(value); end

  def identity?(); end

  def lastAccessTime(); end

  def lastAccessTime=(value); end

  def lastAccessTime?(); end

  def ratePerSecond(); end

  def ratePerSecond=(value); end

  def ratePerSecond?(); end
end

class CadenceThrift::QueryFailedError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::QueryRejected
  def closeStatus(); end

  def closeStatus=(value); end

  def closeStatus?(); end
end

class CadenceThrift::QueryWorkflowRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end

  def query(); end

  def query=(value); end

  def query?(); end

  def queryRejectCondition(); end

  def queryRejectCondition=(value); end

  def queryRejectCondition?(); end
end

class CadenceThrift::QueryWorkflowResponse
  def queryRejected(); end

  def queryRejected=(value); end

  def queryRejected?(); end

  def queryResult(); end

  def queryResult=(value); end

  def queryResult?(); end
end

class CadenceThrift::RecordActivityTaskHeartbeatByIDRequest
  def activityID(); end

  def activityID=(value); end

  def activityID?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def runID(); end

  def runID=(value); end

  def runID?(); end

  def workflowID(); end

  def workflowID=(value); end

  def workflowID?(); end
end

class CadenceThrift::RecordActivityTaskHeartbeatRequest
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RecordActivityTaskHeartbeatResponse
  def cancelRequested(); end

  def cancelRequested=(value); end

  def cancelRequested?(); end
end

class CadenceThrift::RecordMarkerDecisionAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def markerName(); end

  def markerName=(value); end

  def markerName?(); end
end

class CadenceThrift::RegisterDomainRequest
  def activeClusterName(); end

  def activeClusterName=(value); end

  def activeClusterName?(); end

  def clusters(); end

  def clusters=(value); end

  def clusters?(); end

  def data(); end

  def data=(value); end

  def data?(); end

  def description(); end

  def description=(value); end

  def description?(); end

  def emitMetric(); end

  def emitMetric=(value); end

  def emitMetric?(); end

  def historyArchivalStatus(); end

  def historyArchivalStatus=(value); end

  def historyArchivalStatus?(); end

  def historyArchivalURI(); end

  def historyArchivalURI=(value); end

  def historyArchivalURI?(); end

  def isGlobalDomain(); end

  def isGlobalDomain=(value); end

  def isGlobalDomain?(); end

  def name(); end

  def name=(value); end

  def name?(); end

  def ownerEmail(); end

  def ownerEmail=(value); end

  def ownerEmail?(); end

  def securityToken(); end

  def securityToken=(value); end

  def securityToken?(); end

  def visibilityArchivalStatus(); end

  def visibilityArchivalStatus=(value); end

  def visibilityArchivalStatus?(); end

  def visibilityArchivalURI(); end

  def visibilityArchivalURI=(value); end

  def visibilityArchivalURI?(); end

  def workflowExecutionRetentionPeriodInDays(); end

  def workflowExecutionRetentionPeriodInDays=(value); end

  def workflowExecutionRetentionPeriodInDays?(); end
end

class CadenceThrift::RemoveTaskRequest
  def shardID(); end

  def shardID=(value); end

  def shardID?(); end

  def taskID(); end

  def taskID=(value); end

  def taskID?(); end

  def type(); end

  def type=(value); end

  def type?(); end
end

class CadenceThrift::ReplicationInfo
  def lastEventId(); end

  def lastEventId=(value); end

  def lastEventId?(); end

  def version(); end

  def version=(value); end

  def version?(); end
end

class CadenceThrift::RequestCancelActivityTaskDecisionAttributes
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end
end

class CadenceThrift::RequestCancelActivityTaskFailedEventAttributes
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end

  def cause(); end

  def cause=(value); end

  def cause?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end
end

class CadenceThrift::RequestCancelExternalWorkflowExecutionDecisionAttributes
  def childWorkflowOnly(); end

  def childWorkflowOnly=(value); end

  def childWorkflowOnly?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def runId(); end

  def runId=(value); end

  def runId?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end
end

class CadenceThrift::RequestCancelExternalWorkflowExecutionFailedEventAttributes
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::RequestCancelExternalWorkflowExecutionInitiatedEventAttributes
  def childWorkflowOnly(); end

  def childWorkflowOnly=(value); end

  def childWorkflowOnly?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::RequestCancelWorkflowExecutionRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::ResetPointInfo
  def binaryChecksum(); end

  def binaryChecksum=(value); end

  def binaryChecksum?(); end

  def createdTimeNano(); end

  def createdTimeNano=(value); end

  def createdTimeNano?(); end

  def expiringTimeNano(); end

  def expiringTimeNano=(value); end

  def expiringTimeNano?(); end

  def firstDecisionCompletedId(); end

  def firstDecisionCompletedId=(value); end

  def firstDecisionCompletedId?(); end

  def resettable(); end

  def resettable=(value); end

  def resettable?(); end

  def runId(); end

  def runId=(value); end

  def runId?(); end
end

class CadenceThrift::ResetPoints
  def points(); end

  def points=(value); end

  def points?(); end
end

class CadenceThrift::ResetStickyTaskListRequest
  def domain(); end

  def domain=(value); end

  def domain?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end
end

class CadenceThrift::ResetWorkflowExecutionRequest
  def decisionFinishEventId(); end

  def decisionFinishEventId=(value); end

  def decisionFinishEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::ResetWorkflowExecutionResponse
  def runId(); end

  def runId=(value); end

  def runId?(); end
end

class CadenceThrift::RespondActivityTaskCanceledByIDRequest
  def activityID(); end

  def activityID=(value); end

  def activityID?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def runID(); end

  def runID=(value); end

  def runID?(); end

  def workflowID(); end

  def workflowID=(value); end

  def workflowID?(); end
end

class CadenceThrift::RespondActivityTaskCanceledRequest
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RespondActivityTaskCompletedByIDRequest
  def activityID(); end

  def activityID=(value); end

  def activityID?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def result(); end

  def result=(value); end

  def result?(); end

  def runID(); end

  def runID=(value); end

  def runID?(); end

  def workflowID(); end

  def workflowID=(value); end

  def workflowID?(); end
end

class CadenceThrift::RespondActivityTaskCompletedRequest
  def identity(); end

  def identity=(value); end

  def identity?(); end

  def result(); end

  def result=(value); end

  def result?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RespondActivityTaskFailedByIDRequest
  def activityID(); end

  def activityID=(value); end

  def activityID?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def runID(); end

  def runID=(value); end

  def runID?(); end

  def workflowID(); end

  def workflowID=(value); end

  def workflowID?(); end
end

class CadenceThrift::RespondActivityTaskFailedRequest
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RespondDecisionTaskCompletedRequest
  def binaryChecksum(); end

  def binaryChecksum=(value); end

  def binaryChecksum?(); end

  def decisions(); end

  def decisions=(value); end

  def decisions?(); end

  def executionContext(); end

  def executionContext=(value); end

  def executionContext?(); end

  def forceCreateNewDecisionTask(); end

  def forceCreateNewDecisionTask=(value); end

  def forceCreateNewDecisionTask?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def queryResults(); end

  def queryResults=(value); end

  def queryResults?(); end

  def returnNewDecisionTask(); end

  def returnNewDecisionTask=(value); end

  def returnNewDecisionTask?(); end

  def stickyAttributes(); end

  def stickyAttributes=(value); end

  def stickyAttributes?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RespondDecisionTaskCompletedResponse
  def decisionTask(); end

  def decisionTask=(value); end

  def decisionTask?(); end
end

class CadenceThrift::RespondDecisionTaskFailedRequest
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RespondQueryTaskCompletedRequest
  def completedType(); end

  def completedType=(value); end

  def completedType?(); end

  def errorMessage(); end

  def errorMessage=(value); end

  def errorMessage?(); end

  def queryResult(); end

  def queryResult=(value); end

  def queryResult?(); end

  def taskToken(); end

  def taskToken=(value); end

  def taskToken?(); end
end

class CadenceThrift::RetryPolicy
  def backoffCoefficient(); end

  def backoffCoefficient=(value); end

  def backoffCoefficient?(); end

  def expirationIntervalInSeconds(); end

  def expirationIntervalInSeconds=(value); end

  def expirationIntervalInSeconds?(); end

  def initialIntervalInSeconds(); end

  def initialIntervalInSeconds=(value); end

  def initialIntervalInSeconds?(); end

  def maximumAttempts(); end

  def maximumAttempts=(value); end

  def maximumAttempts?(); end

  def maximumIntervalInSeconds(); end

  def maximumIntervalInSeconds=(value); end

  def maximumIntervalInSeconds?(); end

  def nonRetriableErrorReasons(); end

  def nonRetriableErrorReasons=(value); end

  def nonRetriableErrorReasons?(); end
end

class CadenceThrift::RetryTaskError
  def domainId(); end

  def domainId=(value); end

  def domainId?(); end

  def initialize(*args, &block); end

  def message=(value); end

  def message?(); end

  def nextEventId(); end

  def nextEventId=(value); end

  def nextEventId?(); end

  def runId(); end

  def runId=(value); end

  def runId?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end
end

class CadenceThrift::ScheduleActivityTaskDecisionAttributes
  def activityId(); end

  def activityId=(value); end

  def activityId?(); end

  def activityType(); end

  def activityType=(value); end

  def activityType?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def heartbeatTimeoutSeconds(); end

  def heartbeatTimeoutSeconds=(value); end

  def heartbeatTimeoutSeconds?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def scheduleToCloseTimeoutSeconds(); end

  def scheduleToCloseTimeoutSeconds=(value); end

  def scheduleToCloseTimeoutSeconds?(); end

  def scheduleToStartTimeoutSeconds(); end

  def scheduleToStartTimeoutSeconds=(value); end

  def scheduleToStartTimeoutSeconds?(); end

  def startToCloseTimeoutSeconds(); end

  def startToCloseTimeoutSeconds=(value); end

  def startToCloseTimeoutSeconds?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end
end

class CadenceThrift::SearchAttributes
  def indexedFields(); end

  def indexedFields=(value); end

  def indexedFields?(); end
end

class CadenceThrift::ServiceBusyError
  def message=(value); end

  def message?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::SignalExternalWorkflowExecutionDecisionAttributes
  def childWorkflowOnly(); end

  def childWorkflowOnly=(value); end

  def childWorkflowOnly?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def signalName(); end

  def signalName=(value); end

  def signalName?(); end
end

class CadenceThrift::SignalExternalWorkflowExecutionFailedEventAttributes
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::SignalExternalWorkflowExecutionInitiatedEventAttributes
  def childWorkflowOnly(); end

  def childWorkflowOnly=(value); end

  def childWorkflowOnly?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def signalName(); end

  def signalName=(value); end

  def signalName?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::SignalWithStartWorkflowExecutionRequest
  def control(); end

  def control=(value); end

  def control?(); end

  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def signalInput(); end

  def signalInput=(value); end

  def signalInput?(); end

  def signalName(); end

  def signalName=(value); end

  def signalName?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end

  def workflowIdReusePolicy(); end

  def workflowIdReusePolicy=(value); end

  def workflowIdReusePolicy?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::SignalWorkflowExecutionRequest
  def control(); end

  def control=(value); end

  def control?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def signalName(); end

  def signalName=(value); end

  def signalName?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::StartChildWorkflowExecutionDecisionAttributes
  def control(); end

  def control=(value); end

  def control?(); end

  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def parentClosePolicy(); end

  def parentClosePolicy=(value); end

  def parentClosePolicy?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end

  def workflowIdReusePolicy(); end

  def workflowIdReusePolicy=(value); end

  def workflowIdReusePolicy?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::StartChildWorkflowExecutionFailedEventAttributes
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def control(); end

  def control=(value); end

  def control?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def initiatedEventId(); end

  def initiatedEventId=(value); end

  def initiatedEventId?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::StartChildWorkflowExecutionInitiatedEventAttributes
  def control(); end

  def control=(value); end

  def control?(); end

  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def parentClosePolicy(); end

  def parentClosePolicy=(value); end

  def parentClosePolicy?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end

  def workflowIdReusePolicy(); end

  def workflowIdReusePolicy=(value); end

  def workflowIdReusePolicy?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::StartTimeFilter
  def earliestTime(); end

  def earliestTime=(value); end

  def earliestTime?(); end

  def latestTime(); end

  def latestTime=(value); end

  def latestTime?(); end
end

class CadenceThrift::StartTimerDecisionAttributes
  def startToFireTimeoutSeconds(); end

  def startToFireTimeoutSeconds=(value); end

  def startToFireTimeoutSeconds?(); end

  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::StartWorkflowExecutionRequest
  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def requestId(); end

  def requestId=(value); end

  def requestId?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end

  def workflowIdReusePolicy(); end

  def workflowIdReusePolicy=(value); end

  def workflowIdReusePolicy?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::StartWorkflowExecutionResponse
  def runId(); end

  def runId=(value); end

  def runId?(); end
end

class CadenceThrift::StickyExecutionAttributes
  def scheduleToStartTimeoutSeconds(); end

  def scheduleToStartTimeoutSeconds=(value); end

  def scheduleToStartTimeoutSeconds?(); end

  def workerTaskList(); end

  def workerTaskList=(value); end

  def workerTaskList?(); end
end

class CadenceThrift::TaskIDBlock
  def endID(); end

  def endID=(value); end

  def endID?(); end

  def startID(); end

  def startID=(value); end

  def startID?(); end
end

class CadenceThrift::TaskList
  def kind(); end

  def kind=(value); end

  def kind?(); end

  def name(); end

  def name=(value); end

  def name?(); end
end

class CadenceThrift::TaskListMetadata
  def maxTasksPerSecond(); end

  def maxTasksPerSecond=(value); end

  def maxTasksPerSecond?(); end
end

class CadenceThrift::TaskListStatus
  def ackLevel(); end

  def ackLevel=(value); end

  def ackLevel?(); end

  def backlogCountHint(); end

  def backlogCountHint=(value); end

  def backlogCountHint?(); end

  def ratePerSecond(); end

  def ratePerSecond=(value); end

  def ratePerSecond?(); end

  def readLevel(); end

  def readLevel=(value); end

  def readLevel?(); end

  def taskIDBlock(); end

  def taskIDBlock=(value); end

  def taskIDBlock?(); end
end

class CadenceThrift::TerminateWorkflowExecutionRequest
  def details(); end

  def details=(value); end

  def details?(); end

  def domain(); end

  def domain=(value); end

  def domain?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end

  def workflowExecution(); end

  def workflowExecution=(value); end

  def workflowExecution?(); end
end

class CadenceThrift::TimerCanceledEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::TimerFiredEventAttributes
  def startedEventId(); end

  def startedEventId=(value); end

  def startedEventId?(); end

  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::TimerStartedEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def startToFireTimeoutSeconds(); end

  def startToFireTimeoutSeconds=(value); end

  def startToFireTimeoutSeconds?(); end

  def timerId(); end

  def timerId=(value); end

  def timerId?(); end
end

class CadenceThrift::TransientDecisionInfo
  def scheduledEvent(); end

  def scheduledEvent=(value); end

  def scheduledEvent?(); end

  def startedEvent(); end

  def startedEvent=(value); end

  def startedEvent?(); end
end

class CadenceThrift::UpdateDomainInfo
  def data(); end

  def data=(value); end

  def data?(); end

  def description(); end

  def description=(value); end

  def description?(); end

  def ownerEmail(); end

  def ownerEmail=(value); end

  def ownerEmail?(); end
end

class CadenceThrift::UpdateDomainRequest
  def configuration(); end

  def configuration=(value); end

  def configuration?(); end

  def deleteBadBinary(); end

  def deleteBadBinary=(value); end

  def deleteBadBinary?(); end

  def name(); end

  def name=(value); end

  def name?(); end

  def replicationConfiguration(); end

  def replicationConfiguration=(value); end

  def replicationConfiguration?(); end

  def securityToken(); end

  def securityToken=(value); end

  def securityToken?(); end

  def updatedInfo(); end

  def updatedInfo=(value); end

  def updatedInfo?(); end
end

class CadenceThrift::UpdateDomainResponse
  def configuration(); end

  def configuration=(value); end

  def configuration?(); end

  def domainInfo(); end

  def domainInfo=(value); end

  def domainInfo?(); end

  def failoverVersion(); end

  def failoverVersion=(value); end

  def failoverVersion?(); end

  def isGlobalDomain(); end

  def isGlobalDomain=(value); end

  def isGlobalDomain?(); end

  def replicationConfiguration(); end

  def replicationConfiguration=(value); end

  def replicationConfiguration?(); end
end

class CadenceThrift::UpsertWorkflowSearchAttributesDecisionAttributes
  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end
end

class CadenceThrift::UpsertWorkflowSearchAttributesEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end
end

class CadenceThrift::WorkflowExecution
  def runId(); end

  def runId=(value); end

  def runId?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end
end

class CadenceThrift::WorkflowExecutionAlreadyStartedError
  def initialize(*args, &block); end

  def message=(value); end

  def message?(); end

  def runId(); end

  def runId=(value); end

  def runId?(); end

  def startRequestId(); end

  def startRequestId=(value); end

  def startRequestId?(); end

  def struct_initialize(d=T.unsafe(nil), &block); end
end

class CadenceThrift::WorkflowExecutionCancelRequestedEventAttributes
  def cause(); end

  def cause=(value); end

  def cause?(); end

  def externalInitiatedEventId(); end

  def externalInitiatedEventId=(value); end

  def externalInitiatedEventId?(); end

  def externalWorkflowExecution(); end

  def externalWorkflowExecution=(value); end

  def externalWorkflowExecution?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end
end

class CadenceThrift::WorkflowExecutionCanceledEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def details(); end

  def details=(value); end

  def details?(); end
end

class CadenceThrift::WorkflowExecutionCompletedEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def result(); end

  def result=(value); end

  def result?(); end
end

class CadenceThrift::WorkflowExecutionConfiguration
  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end
end

class CadenceThrift::WorkflowExecutionContinuedAsNewEventAttributes
  def backoffStartIntervalInSeconds(); end

  def backoffStartIntervalInSeconds=(value); end

  def backoffStartIntervalInSeconds?(); end

  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def failureDetails(); end

  def failureDetails=(value); end

  def failureDetails?(); end

  def failureReason(); end

  def failureReason=(value); end

  def failureReason?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def initiator(); end

  def initiator=(value); end

  def initiator?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def lastCompletionResult(); end

  def lastCompletionResult=(value); end

  def lastCompletionResult?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def newExecutionRunId(); end

  def newExecutionRunId=(value); end

  def newExecutionRunId?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::WorkflowExecutionFailedEventAttributes
  def decisionTaskCompletedEventId(); end

  def decisionTaskCompletedEventId=(value); end

  def decisionTaskCompletedEventId?(); end

  def details(); end

  def details=(value); end

  def details?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end
end

class CadenceThrift::WorkflowExecutionFilter
  def runId(); end

  def runId=(value); end

  def runId?(); end

  def workflowId(); end

  def workflowId=(value); end

  def workflowId?(); end
end

class CadenceThrift::WorkflowExecutionInfo
  def autoResetPoints(); end

  def autoResetPoints=(value); end

  def autoResetPoints?(); end

  def closeStatus(); end

  def closeStatus=(value); end

  def closeStatus?(); end

  def closeTime(); end

  def closeTime=(value); end

  def closeTime?(); end

  def execution(); end

  def execution=(value); end

  def execution?(); end

  def executionTime(); end

  def executionTime=(value); end

  def executionTime?(); end

  def historyLength(); end

  def historyLength=(value); end

  def historyLength?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def parentDomainId(); end

  def parentDomainId=(value); end

  def parentDomainId?(); end

  def parentExecution(); end

  def parentExecution=(value); end

  def parentExecution?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def startTime(); end

  def startTime=(value); end

  def startTime?(); end

  def type(); end

  def type=(value); end

  def type?(); end
end

class CadenceThrift::WorkflowExecutionSignaledEventAttributes
  def identity(); end

  def identity=(value); end

  def identity?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def signalName(); end

  def signalName=(value); end

  def signalName?(); end
end

class CadenceThrift::WorkflowExecutionStartedEventAttributes
  def attempt(); end

  def attempt=(value); end

  def attempt?(); end

  def continuedExecutionRunId(); end

  def continuedExecutionRunId=(value); end

  def continuedExecutionRunId?(); end

  def continuedFailureDetails(); end

  def continuedFailureDetails=(value); end

  def continuedFailureDetails?(); end

  def continuedFailureReason(); end

  def continuedFailureReason=(value); end

  def continuedFailureReason?(); end

  def cronSchedule(); end

  def cronSchedule=(value); end

  def cronSchedule?(); end

  def executionStartToCloseTimeoutSeconds(); end

  def executionStartToCloseTimeoutSeconds=(value); end

  def executionStartToCloseTimeoutSeconds?(); end

  def expirationTimestamp(); end

  def expirationTimestamp=(value); end

  def expirationTimestamp?(); end

  def firstDecisionTaskBackoffSeconds(); end

  def firstDecisionTaskBackoffSeconds=(value); end

  def firstDecisionTaskBackoffSeconds?(); end

  def firstExecutionRunId(); end

  def firstExecutionRunId=(value); end

  def firstExecutionRunId?(); end

  def header(); end

  def header=(value); end

  def header?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def initiator(); end

  def initiator=(value); end

  def initiator?(); end

  def input(); end

  def input=(value); end

  def input?(); end

  def lastCompletionResult(); end

  def lastCompletionResult=(value); end

  def lastCompletionResult?(); end

  def memo(); end

  def memo=(value); end

  def memo?(); end

  def originalExecutionRunId(); end

  def originalExecutionRunId=(value); end

  def originalExecutionRunId?(); end

  def parentInitiatedEventId(); end

  def parentInitiatedEventId=(value); end

  def parentInitiatedEventId?(); end

  def parentWorkflowDomain(); end

  def parentWorkflowDomain=(value); end

  def parentWorkflowDomain?(); end

  def parentWorkflowExecution(); end

  def parentWorkflowExecution=(value); end

  def parentWorkflowExecution?(); end

  def prevAutoResetPoints(); end

  def prevAutoResetPoints=(value); end

  def prevAutoResetPoints?(); end

  def retryPolicy(); end

  def retryPolicy=(value); end

  def retryPolicy?(); end

  def searchAttributes(); end

  def searchAttributes=(value); end

  def searchAttributes?(); end

  def taskList(); end

  def taskList=(value); end

  def taskList?(); end

  def taskStartToCloseTimeoutSeconds(); end

  def taskStartToCloseTimeoutSeconds=(value); end

  def taskStartToCloseTimeoutSeconds?(); end

  def workflowType(); end

  def workflowType=(value); end

  def workflowType?(); end
end

class CadenceThrift::WorkflowExecutionTerminatedEventAttributes
  def details(); end

  def details=(value); end

  def details?(); end

  def identity(); end

  def identity=(value); end

  def identity?(); end

  def reason(); end

  def reason=(value); end

  def reason?(); end
end

class CadenceThrift::WorkflowExecutionTimedOutEventAttributes
  def timeoutType(); end

  def timeoutType=(value); end

  def timeoutType?(); end
end

class CadenceThrift::WorkflowQuery
  def queryArgs(); end

  def queryArgs=(value); end

  def queryArgs?(); end

  def queryType(); end

  def queryType=(value); end

  def queryType?(); end
end

class CadenceThrift::WorkflowQueryResult
  def answer(); end

  def answer=(value); end

  def answer?(); end

  def errorDetails(); end

  def errorDetails=(value); end

  def errorDetails?(); end

  def errorReason(); end

  def errorReason=(value); end

  def errorReason?(); end

  def resultType(); end

  def resultType=(value); end

  def resultType?(); end
end

class CadenceThrift::WorkflowService::CountWorkflowExecutions_args
  def countRequest(); end

  def countRequest=(value); end

  def countRequest?(); end
end

class CadenceThrift::WorkflowService::CountWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::DeprecateDomain_args
  def deprecateRequest(); end

  def deprecateRequest=(value); end

  def deprecateRequest?(); end
end

class CadenceThrift::WorkflowService::DeprecateDomain_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::DescribeDomain_args
  def describeRequest(); end

  def describeRequest=(value); end

  def describeRequest?(); end
end

class CadenceThrift::WorkflowService::DescribeDomain_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::DescribeTaskList_args
  def request(); end

  def request=(value); end

  def request?(); end
end

class CadenceThrift::WorkflowService::DescribeTaskList_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::DescribeWorkflowExecution_args
  def describeRequest(); end

  def describeRequest=(value); end

  def describeRequest?(); end
end

class CadenceThrift::WorkflowService::DescribeWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::GetSearchAttributes_result
  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::GetWorkflowExecutionHistory_args
  def getRequest(); end

  def getRequest=(value); end

  def getRequest?(); end
end

class CadenceThrift::WorkflowService::GetWorkflowExecutionHistory_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ListArchivedWorkflowExecutions_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ListArchivedWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ListClosedWorkflowExecutions_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ListClosedWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ListDomains_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ListDomains_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ListOpenWorkflowExecutions_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ListOpenWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ListWorkflowExecutions_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ListWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::PollForActivityTask_args
  def pollRequest(); end

  def pollRequest=(value); end

  def pollRequest?(); end
end

class CadenceThrift::WorkflowService::PollForActivityTask_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::PollForDecisionTask_args
  def pollRequest(); end

  def pollRequest=(value); end

  def pollRequest?(); end
end

class CadenceThrift::WorkflowService::PollForDecisionTask_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::QueryWorkflow_args
  def queryRequest(); end

  def queryRequest=(value); end

  def queryRequest?(); end
end

class CadenceThrift::WorkflowService::QueryWorkflow_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def queryFailedError(); end

  def queryFailedError=(value); end

  def queryFailedError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::RecordActivityTaskHeartbeatByID_args
  def heartbeatRequest(); end

  def heartbeatRequest=(value); end

  def heartbeatRequest?(); end
end

class CadenceThrift::WorkflowService::RecordActivityTaskHeartbeatByID_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::RecordActivityTaskHeartbeat_args
  def heartbeatRequest(); end

  def heartbeatRequest=(value); end

  def heartbeatRequest?(); end
end

class CadenceThrift::WorkflowService::RecordActivityTaskHeartbeat_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::RegisterDomain_args
  def registerRequest(); end

  def registerRequest=(value); end

  def registerRequest?(); end
end

class CadenceThrift::WorkflowService::RegisterDomain_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainExistsError(); end

  def domainExistsError=(value); end

  def domainExistsError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RequestCancelWorkflowExecution_args
  def cancelRequest(); end

  def cancelRequest=(value); end

  def cancelRequest?(); end
end

class CadenceThrift::WorkflowService::RequestCancelWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def cancellationAlreadyRequestedError(); end

  def cancellationAlreadyRequestedError=(value); end

  def cancellationAlreadyRequestedError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::ResetStickyTaskList_args
  def resetRequest(); end

  def resetRequest=(value); end

  def resetRequest?(); end
end

class CadenceThrift::WorkflowService::ResetStickyTaskList_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::ResetWorkflowExecution_args
  def resetRequest(); end

  def resetRequest=(value); end

  def resetRequest?(); end
end

class CadenceThrift::WorkflowService::ResetWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCanceledByID_args
  def canceledRequest(); end

  def canceledRequest=(value); end

  def canceledRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCanceledByID_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCanceled_args
  def canceledRequest(); end

  def canceledRequest=(value); end

  def canceledRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCanceled_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCompletedByID_args
  def completeRequest(); end

  def completeRequest=(value); end

  def completeRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCompletedByID_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCompleted_args
  def completeRequest(); end

  def completeRequest=(value); end

  def completeRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskCompleted_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskFailedByID_args
  def failRequest(); end

  def failRequest=(value); end

  def failRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskFailedByID_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskFailed_args
  def failRequest(); end

  def failRequest=(value); end

  def failRequest?(); end
end

class CadenceThrift::WorkflowService::RespondActivityTaskFailed_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondDecisionTaskCompleted_args
  def completeRequest(); end

  def completeRequest=(value); end

  def completeRequest?(); end
end

class CadenceThrift::WorkflowService::RespondDecisionTaskCompleted_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::RespondDecisionTaskFailed_args
  def failedRequest(); end

  def failedRequest=(value); end

  def failedRequest?(); end
end

class CadenceThrift::WorkflowService::RespondDecisionTaskFailed_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::RespondQueryTaskCompleted_args
  def completeRequest(); end

  def completeRequest=(value); end

  def completeRequest?(); end
end

class CadenceThrift::WorkflowService::RespondQueryTaskCompleted_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::ScanWorkflowExecutions_args
  def listRequest(); end

  def listRequest=(value); end

  def listRequest?(); end
end

class CadenceThrift::WorkflowService::ScanWorkflowExecutions_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::SignalWithStartWorkflowExecution_args
  def signalWithStartRequest(); end

  def signalWithStartRequest=(value); end

  def signalWithStartRequest?(); end
end

class CadenceThrift::WorkflowService::SignalWithStartWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end

  def workflowAlreadyStartedError(); end

  def workflowAlreadyStartedError=(value); end

  def workflowAlreadyStartedError?(); end
end

class CadenceThrift::WorkflowService::SignalWorkflowExecution_args
  def signalRequest(); end

  def signalRequest=(value); end

  def signalRequest?(); end
end

class CadenceThrift::WorkflowService::SignalWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::StartWorkflowExecution_args
  def startRequest(); end

  def startRequest=(value); end

  def startRequest?(); end
end

class CadenceThrift::WorkflowService::StartWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def sessionAlreadyExistError(); end

  def sessionAlreadyExistError=(value); end

  def sessionAlreadyExistError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowService::TerminateWorkflowExecution_args
  def terminateRequest(); end

  def terminateRequest=(value); end

  def terminateRequest?(); end
end

class CadenceThrift::WorkflowService::TerminateWorkflowExecution_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def limitExceededError(); end

  def limitExceededError=(value); end

  def limitExceededError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end
end

class CadenceThrift::WorkflowService::UpdateDomain_args
  def updateRequest(); end

  def updateRequest=(value); end

  def updateRequest?(); end
end

class CadenceThrift::WorkflowService::UpdateDomain_result
  def badRequestError(); end

  def badRequestError=(value); end

  def badRequestError?(); end

  def clientVersionNotSupportedError(); end

  def clientVersionNotSupportedError=(value); end

  def clientVersionNotSupportedError?(); end

  def domainNotActiveError(); end

  def domainNotActiveError=(value); end

  def domainNotActiveError?(); end

  def entityNotExistError(); end

  def entityNotExistError=(value); end

  def entityNotExistError?(); end

  def internalServiceError(); end

  def internalServiceError=(value); end

  def internalServiceError?(); end

  def serviceBusyError(); end

  def serviceBusyError=(value); end

  def serviceBusyError?(); end

  def success(); end

  def success=(value); end

  def success?(); end
end

class CadenceThrift::WorkflowType
  def name(); end

  def name=(value); end

  def name?(); end
end

class CadenceThrift::WorkflowTypeFilter
  def name(); end

  def name=(value); end

  def name?(); end
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::HTML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

module CodeRay::Encoders::HTML::Output
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Java
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Scanner
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

module Coveralls
  VERSION = ::T.let(nil, ::T.untyped)
end

class Coveralls::API
  API_BASE = ::T.let(nil, ::T.untyped)
  API_DOMAIN = ::T.let(nil, ::T.untyped)
  API_HOST = ::T.let(nil, ::T.untyped)
  API_PROTOCOL = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

DSLKit = Tins

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
  FILTER_PATTERN = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class Fabricate
end

class Fabricate
  def self.attributes_for(name, overrides=T.unsafe(nil), &block); end

  def self.attributes_for_times(count, name, overrides=T.unsafe(nil), &block); end

  def self.build(name, overrides=T.unsafe(nil), &block); end

  def self.build_times(count, name, overrides=T.unsafe(nil), &block); end

  def self.create(name, overrides=T.unsafe(nil), &block); end

  def self.fail_if_initializing(name); end

  def self.schematic(name); end

  def self.sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end

  def self.times(count, name, overrides=T.unsafe(nil), &block); end

  def self.to_params(name, overrides=T.unsafe(nil), &block); end
end

module Fabrication::Cucumber
end

module Fabrication::Cucumber::Fabrications
end

module Fabrication::Cucumber::Fabrications
  def self.[](fabricator); end

  def self.[]=(fabricator, fabrication); end
end

class Fabrication::Cucumber::StepFabricator
  def from_table(table, extra=T.unsafe(nil)); end

  def has_many(children); end

  def initialize(model_name, opts=T.unsafe(nil)); end

  def klass(); end

  def model(); end

  def n(count, attrs=T.unsafe(nil)); end

  def parent(); end
end

class Fabrication::Cucumber::StepFabricator
end

module Fabrication::Cucumber
end

class Fabrication::DuplicateFabricatorError
  def initialize(string); end
end

class Fabrication::DuplicateFabricatorError
end

class Fabrication::InfiniteRecursionError
  def initialize(name); end
end

class Fabrication::InfiniteRecursionError
end

class Fabrication::MisplacedFabricateError
  def initialize(name); end
end

class Fabrication::MisplacedFabricateError
end

class Fabrication::Schematic::Attribute
  def initialize(klass, name, value, params=T.unsafe(nil), &block); end

  def klass(); end

  def klass=(klass); end

  def name(); end

  def name=(name); end

  def params(); end

  def params=(params); end

  def processed_value(processed_attributes); end

  def transient!(); end

  def transient?(); end

  def value(); end

  def value=(value); end

  def value_proc?(); end

  def value_static?(); end
end

class Fabrication::Schematic::Attribute
end

class Fabrication::Schematic::Definition
  GENERATORS = ::T.let(nil, ::T.untyped)
end

class Fabrication::Schematic::Evaluator
  def after_build(&block); end

  def after_create(&block); end

  def after_save(&block); end

  def after_validation(&block); end

  def before_create(&block); end

  def before_save(&block); end

  def before_validation(&block); end

  def init_with(*args); end

  def initialize_with(&block); end

  def method_missing(method_name, *args, &block); end

  def on_init(&block); end

  def process(definition, &block); end

  def transient(*field_names); end
end

class Fabrication::Schematic::Evaluator
end

class Fabrication::Schematic::Runner
  def initialize(klass); end

  def klass(); end

  def klass=(klass); end

  def sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end
end

class Fabrication::Schematic::Runner
end

class Fabrication::Sequencer
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Fabrication::Sequencer
  def self.reset(); end

  def self.sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end

  def self.sequence_blocks(); end

  def self.sequences(); end
end

class Fabrication::Support
end

class Fabrication::Support
  def self.class_for(class_or_to_s); end

  def self.constantize(camel_cased_word); end

  def self.extract_options!(args); end

  def self.fabricatable?(name); end

  def self.find_definitions(); end

  def self.hash_class(); end

  def self.singularize(string); end

  def self.underscore(string); end

  def self.variable_name_to_class_name(name); end
end

class Fabrication::Transform
end

class Fabrication::Transform
  def self.apply_to(schematic, attributes_hash); end

  def self.clear_all(); end

  def self.define(attribute, transform); end

  def self.only_for(schematic, attribute, transform); end
end

class Fabrication::UnfabricatableError
  def initialize(name, original_error); end
end

class Fabrication::UnfabricatableError
end

class Fabrication::UnknownFabricatorError
  def initialize(name); end
end

class Fabrication::UnknownFabricatorError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def transfer(*_); end
end

class Fiber
  def self.current(); end
end

class File
  def self.exists?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def plugins(); end
end

class Gem::Command
  def deprecated?(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def filters_bundler?(); end
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(); end
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), extension_dir=T.unsafe(nil)); end

  def self.get_relative_path(path, base); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def generate_plugins(); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def original_uri(); end

  def original_uri=(original_uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def unused_unwind_options(); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def possibility_set(); end

  def possibility_set=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*_); end

  def self.members(); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::VersionConflict
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.latest_spec_for(name); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.find_config_file(); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.load_file(filespec, opts=T.unsafe(nil)); end

  def self.load_file!(filespec, opts=T.unsafe(nil)); end
end

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  THREAD_SYNC_DELAY = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

module Oj
  CUSTOM_MIMIC_JSON_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Oj::CStack
end

class Oj::CStack
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
end

class RSpec::Mocks::AnyInstance::StubChain
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

Spruz = Tins

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Sync
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sync_m
  def initialize(*args); end
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Term::ANSIColor
  ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
  COLORED_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_ARRAY = ::T.let(nil, ::T.untyped)
  VERSION_BUILD = ::T.let(nil, ::T.untyped)
  VERSION_MAJOR = ::T.let(nil, ::T.untyped)
  VERSION_MINOR = ::T.let(nil, ::T.untyped)
end

class TestActivity
end

class TestActivity
end

class TestCadenceOverrideWorkflow
end

class TestCadenceOverrideWorkflow
end

class TestChainMiddleware
  def call(_); end
end

class TestChainMiddleware
end

class TestClass
end

class TestClass
end

class TestEntryMiddleware
  def call(_); end
end

class TestEntryMiddleware
end

class TestEntryMiddlewareWithArguments
  def call(_); end

  def initialize(arg_1, arg2); end
end

class TestEntryMiddlewareWithArguments
end

class TestPollerMiddleware
  def call(_); end

  def initialize(_); end
end

class TestPollerMiddleware
end

class TestSagaActivity
end

class TestSagaActivity
end

class TestSagaConcernActivity1
end

class TestSagaConcernActivity1
end

class TestSagaConcernActivity2
end

class TestSagaConcernActivity2
end

class TestSagaConcernActivity3
end

class TestSagaConcernActivity3
end

class TestSagaConcernError
end

class TestSagaConcernError
end

class TestSagaConcernWorkflow
  include ::Cadence::Saga::Concern
  def execute(do_not_compensate_on: T.unsafe(nil), compensate_on: T.unsafe(nil)); end
end

class TestSagaConcernWorkflow
end

class TestStartWorkflow
end

class TestStartWorkflow
end

class TestWorkerActivity
end

class TestWorkerActivity
end

class TestWorkerActivityMiddleware
  def call(_); end
end

class TestWorkerActivityMiddleware
end

class TestWorkerDecisionMiddleware
  def call(_); end
end

class TestWorkerDecisionMiddleware
end

class TestWorkerWorkflow
end

class TestWorkerWorkflow
end

class TestWorkflow
end

class TestWorkflow
end

class Thor::Shell::Color
  def are_colors_supported?(); end
end

class Thrift::ApplicationException
  BAD_SEQUENCE_ID = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_MESSAGE_TYPE = ::T.let(nil, ::T.untyped)
  INVALID_PROTOCOL = ::T.let(nil, ::T.untyped)
  INVALID_TRANSFORM = ::T.let(nil, ::T.untyped)
  MISSING_RESULT = ::T.let(nil, ::T.untyped)
  PROTOCOL_ERROR = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  UNKNOWN_METHOD = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_CLIENT_TYPE = ::T.let(nil, ::T.untyped)
  WRONG_METHOD_NAME = ::T.let(nil, ::T.untyped)
end

class Thrift::BinaryProtocol
  TYPE_MASK = ::T.let(nil, ::T.untyped)
  VERSION_1 = ::T.let(nil, ::T.untyped)
  VERSION_MASK = ::T.let(nil, ::T.untyped)
end

class Thrift::BufferedTransport
  DEFAULT_BUFFER = ::T.let(nil, ::T.untyped)
end

class Thrift::CompactProtocol
  EVERYTHING_ELSE_MASK = ::T.let(nil, ::T.untyped)
  PROTOCOL_ID = ::T.let(nil, ::T.untyped)
  SEVEN_BIT_MASK = ::T.let(nil, ::T.untyped)
  TSTOP = ::T.let(nil, ::T.untyped)
  TYPE_BITS = ::T.let(nil, ::T.untyped)
  TYPE_MASK = ::T.let(nil, ::T.untyped)
  TYPE_SHIFT_AMOUNT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_MASK = ::T.let(nil, ::T.untyped)
end

class Thrift::CompactProtocol::CompactTypes
  BINARY = ::T.let(nil, ::T.untyped)
  BOOLEAN_FALSE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TRUE = ::T.let(nil, ::T.untyped)
  BYTE = ::T.let(nil, ::T.untyped)
  COMPACT_TO_TTYPE = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  I16 = ::T.let(nil, ::T.untyped)
  I32 = ::T.let(nil, ::T.untyped)
  I64 = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TTYPE_TO_COMPACT = ::T.let(nil, ::T.untyped)
end

class Thrift::MemoryBufferTransport
  GARBAGE_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
end

module Thrift::MessageTypes
  CALL = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  ONEWAY = ::T.let(nil, ::T.untyped)
  REPLY = ::T.let(nil, ::T.untyped)
end

class Thrift::NonblockingServer::IOManager
  DEFAULT_BUFFER = ::T.let(nil, ::T.untyped)
end

class Thrift::ProtocolException
  BAD_VERSION = ::T.let(nil, ::T.untyped)
  DEPTH_LIMIT = ::T.let(nil, ::T.untyped)
  INVALID_DATA = ::T.let(nil, ::T.untyped)
  NEGATIVE_SIZE = ::T.let(nil, ::T.untyped)
  NOT_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  SIZE_LIMIT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

module Thrift::Struct_Union
  CONTAINER_TYPES = ::T.let(nil, ::T.untyped)
end

class Thrift::TransportException
  ALREADY_OPEN = ::T.let(nil, ::T.untyped)
  END_OF_FILE = ::T.let(nil, ::T.untyped)
  NOT_OPEN = ::T.let(nil, ::T.untyped)
  TIMED_OUT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

module Thrift::Types
  BOOL = ::T.let(nil, ::T.untyped)
  BYTE = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  I16 = ::T.let(nil, ::T.untyped)
  I32 = ::T.let(nil, ::T.untyped)
  I64 = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module Tins
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_ARRAY = ::T.let(nil, ::T.untyped)
  VERSION_BUILD = ::T.let(nil, ::T.untyped)
  VERSION_MAJOR = ::T.let(nil, ::T.untyped)
  VERSION_MINOR = ::T.let(nil, ::T.untyped)
end

module Tins::Delegate
  UNSET = ::T.let(nil, ::T.untyped)
end

module Tins::FileBinary::Constants
  BINARY = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

module Tins::Implement
  MESSAGES = ::T.let(nil, ::T.untyped)
end

module Tins::NULL
  extend ::Tins::Null
end

module Tins::SexySingleton
  def self.__init__(klass); end

  def self.included(klass); end
end

module Tins::StringVersion
  LEVELS = ::T.let(nil, ::T.untyped)
  SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Tins::Token
  BASE16_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE32_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE32_EXTENDED_HEX_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE64_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE64_URL_FILENAME_SAFE_ALPHABET = ::T.let(nil, ::T.untyped)
  DEFAULT_ALPHABET = ::T.let(nil, ::T.untyped)
end

module Tins::Unit
  PREFIX_F = ::T.let(nil, ::T.untyped)
  PREFIX_LC = ::T.let(nil, ::T.untyped)
  PREFIX_UC = ::T.let(nil, ::T.untyped)
end

class Tins::Unit::UnitParser
  NUMBER = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
